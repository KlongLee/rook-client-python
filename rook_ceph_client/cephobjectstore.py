"""
This file is automatically generated.
Do not modify.
"""

from typing import List, Dict, Any, Optional

_omit = object()  # to distinguish None and omit

class Gateway(object):
    def __init__(self,
                 type=_omit,  # type: str
                 sslCertificateRef=_omit,  # type: str
                 port=_omit,  # type: int
                 securePort=_omit,  # type: int
                 instances=_omit,  # type: int
                 annotations=_omit,  # type: Any
                 placement=_omit,  # type: Any
                 resources=_omit,  # type: Any
                 ):
        self.type = type
        self.sslCertificateRef = sslCertificateRef
        self.port = port
        self.securePort = securePort
        self.instances = instances
        self.annotations = annotations
        self.placement = placement
        self.resources = resources

    @property
    def type(self):
        # type: () -> str
        if self._type is _omit:
            raise AttributeError('type not found')
        return self._type
    
    @type.setter
    def type(self, new_val):
        # type: (str) -> None
        self._type = new_val
    
    @property
    def sslCertificateRef(self):
        # type: () -> str
        if self._sslCertificateRef is _omit:
            raise AttributeError('sslCertificateRef not found')
        return self._sslCertificateRef
    
    @sslCertificateRef.setter
    def sslCertificateRef(self, new_val):
        # type: (str) -> None
        self._sslCertificateRef = new_val
    
    @property
    def port(self):
        # type: () -> int
        if self._port is _omit:
            raise AttributeError('port not found')
        return self._port
    
    @port.setter
    def port(self, new_val):
        # type: (int) -> None
        self._port = new_val
    
    @property
    def securePort(self):
        # type: () -> int
        if self._securePort is _omit:
            raise AttributeError('securePort not found')
        return self._securePort
    
    @securePort.setter
    def securePort(self, new_val):
        # type: (int) -> None
        self._securePort = new_val
    
    @property
    def instances(self):
        # type: () -> int
        if self._instances is _omit:
            raise AttributeError('instances not found')
        return self._instances
    
    @instances.setter
    def instances(self, new_val):
        # type: (int) -> None
        self._instances = new_val
    
    @property
    def annotations(self):
        # type: () -> Any
        if self._annotations is _omit:
            raise AttributeError('annotations not found')
        return self._annotations
    
    @annotations.setter
    def annotations(self, new_val):
        # type: (Any) -> None
        self._annotations = new_val
    
    @property
    def placement(self):
        # type: () -> Any
        if self._placement is _omit:
            raise AttributeError('placement not found')
        return self._placement
    
    @placement.setter
    def placement(self, new_val):
        # type: (Any) -> None
        self._placement = new_val
    
    @property
    def resources(self):
        # type: () -> Any
        if self._resources is _omit:
            raise AttributeError('resources not found')
        return self._resources
    
    @resources.setter
    def resources(self, new_val):
        # type: (Any) -> None
        self._resources = new_val

    def to_json(self):
        res = {
            'type': self._type,
            'sslCertificateRef': self._sslCertificateRef,
            'port': self._port,
            'securePort': self._securePort,
            'instances': self._instances,
            'annotations': self._annotations,
            'placement': self._placement,
            'resources': self._resources,
        }
        return {k: v for k, v in res.items() if v is not _omit}

    @classmethod
    def from_json(cls, data):
        # type: (dict) -> Gateway
        return cls(
            type=data.get('type', _omit),
            sslCertificateRef=data.get('sslCertificateRef', _omit),
            port=data.get('port', _omit),
            securePort=data.get('securePort', _omit),
            instances=data.get('instances', _omit),
            annotations=data.get('annotations', _omit),
            placement=data.get('placement', _omit),
            resources=data.get('resources', _omit),
        )


class Replicated(object):
    def __init__(self,
                 size=_omit,  # type: int
                 ):
        self.size = size

    @property
    def size(self):
        # type: () -> int
        if self._size is _omit:
            raise AttributeError('size not found')
        return self._size
    
    @size.setter
    def size(self, new_val):
        # type: (int) -> None
        self._size = new_val

    def to_json(self):
        res = {
            'size': self._size,
        }
        return {k: v for k, v in res.items() if v is not _omit}

    @classmethod
    def from_json(cls, data):
        # type: (dict) -> Replicated
        return cls(
            size=data.get('size', _omit),
        )


class ErasureCoded(object):
    def __init__(self,
                 dataChunks=_omit,  # type: int
                 codingChunks=_omit,  # type: int
                 ):
        self.dataChunks = dataChunks
        self.codingChunks = codingChunks

    @property
    def dataChunks(self):
        # type: () -> int
        if self._dataChunks is _omit:
            raise AttributeError('dataChunks not found')
        return self._dataChunks
    
    @dataChunks.setter
    def dataChunks(self, new_val):
        # type: (int) -> None
        self._dataChunks = new_val
    
    @property
    def codingChunks(self):
        # type: () -> int
        if self._codingChunks is _omit:
            raise AttributeError('codingChunks not found')
        return self._codingChunks
    
    @codingChunks.setter
    def codingChunks(self, new_val):
        # type: (int) -> None
        self._codingChunks = new_val

    def to_json(self):
        res = {
            'dataChunks': self._dataChunks,
            'codingChunks': self._codingChunks,
        }
        return {k: v for k, v in res.items() if v is not _omit}

    @classmethod
    def from_json(cls, data):
        # type: (dict) -> ErasureCoded
        return cls(
            dataChunks=data.get('dataChunks', _omit),
            codingChunks=data.get('codingChunks', _omit),
        )


class MetadataPool(object):
    def __init__(self,
                 failureDomain=_omit,  # type: str
                 replicated=_omit,  # type: Replicated
                 erasureCoded=_omit,  # type: ErasureCoded
                 ):
        self.failureDomain = failureDomain
        self.replicated = replicated
        self.erasureCoded = erasureCoded

    @property
    def failureDomain(self):
        # type: () -> str
        if self._failureDomain is _omit:
            raise AttributeError('failureDomain not found')
        return self._failureDomain
    
    @failureDomain.setter
    def failureDomain(self, new_val):
        # type: (str) -> None
        self._failureDomain = new_val
    
    @property
    def replicated(self):
        # type: () -> Replicated
        if self._replicated is _omit:
            raise AttributeError('replicated not found')
        return self._replicated
    
    @replicated.setter
    def replicated(self, new_val):
        # type: (Replicated) -> None
        self._replicated = new_val
    
    @property
    def erasureCoded(self):
        # type: () -> ErasureCoded
        if self._erasureCoded is _omit:
            raise AttributeError('erasureCoded not found')
        return self._erasureCoded
    
    @erasureCoded.setter
    def erasureCoded(self, new_val):
        # type: (ErasureCoded) -> None
        self._erasureCoded = new_val

    def to_json(self):
        res = {
            'failureDomain': self._failureDomain,
            'replicated': self.replicated.to_json() if self._replicated not in [None, _omit] else self._replicated,
            'erasureCoded': self.erasureCoded.to_json() if self._erasureCoded not in [None, _omit] else self._erasureCoded,
        }
        return {k: v for k, v in res.items() if v is not _omit}

    @classmethod
    def from_json(cls, data):
        # type: (dict) -> MetadataPool
        return cls(
            failureDomain=data.get('failureDomain', _omit),
            replicated=Replicated.from_json(data['replicated']) if 'replicated' in data else _omit,
            erasureCoded=ErasureCoded.from_json(data['erasureCoded']) if 'erasureCoded' in data else _omit,
        )


class DataPool(object):
    def __init__(self,
                 failureDomain=_omit,  # type: str
                 replicated=_omit,  # type: Replicated
                 erasureCoded=_omit,  # type: ErasureCoded
                 ):
        self.failureDomain = failureDomain
        self.replicated = replicated
        self.erasureCoded = erasureCoded

    @property
    def failureDomain(self):
        # type: () -> str
        if self._failureDomain is _omit:
            raise AttributeError('failureDomain not found')
        return self._failureDomain
    
    @failureDomain.setter
    def failureDomain(self, new_val):
        # type: (str) -> None
        self._failureDomain = new_val
    
    @property
    def replicated(self):
        # type: () -> Replicated
        if self._replicated is _omit:
            raise AttributeError('replicated not found')
        return self._replicated
    
    @replicated.setter
    def replicated(self, new_val):
        # type: (Replicated) -> None
        self._replicated = new_val
    
    @property
    def erasureCoded(self):
        # type: () -> ErasureCoded
        if self._erasureCoded is _omit:
            raise AttributeError('erasureCoded not found')
        return self._erasureCoded
    
    @erasureCoded.setter
    def erasureCoded(self, new_val):
        # type: (ErasureCoded) -> None
        self._erasureCoded = new_val

    def to_json(self):
        res = {
            'failureDomain': self._failureDomain,
            'replicated': self.replicated.to_json() if self._replicated not in [None, _omit] else self._replicated,
            'erasureCoded': self.erasureCoded.to_json() if self._erasureCoded not in [None, _omit] else self._erasureCoded,
        }
        return {k: v for k, v in res.items() if v is not _omit}

    @classmethod
    def from_json(cls, data):
        # type: (dict) -> DataPool
        return cls(
            failureDomain=data.get('failureDomain', _omit),
            replicated=Replicated.from_json(data['replicated']) if 'replicated' in data else _omit,
            erasureCoded=ErasureCoded.from_json(data['erasureCoded']) if 'erasureCoded' in data else _omit,
        )


class Spec(object):
    def __init__(self,
                 gateway=_omit,  # type: Gateway
                 metadataPool=_omit,  # type: MetadataPool
                 dataPool=_omit,  # type: DataPool
                 ):
        self.gateway = gateway
        self.metadataPool = metadataPool
        self.dataPool = dataPool

    @property
    def gateway(self):
        # type: () -> Gateway
        if self._gateway is _omit:
            raise AttributeError('gateway not found')
        return self._gateway
    
    @gateway.setter
    def gateway(self, new_val):
        # type: (Gateway) -> None
        self._gateway = new_val
    
    @property
    def metadataPool(self):
        # type: () -> MetadataPool
        if self._metadataPool is _omit:
            raise AttributeError('metadataPool not found')
        return self._metadataPool
    
    @metadataPool.setter
    def metadataPool(self, new_val):
        # type: (MetadataPool) -> None
        self._metadataPool = new_val
    
    @property
    def dataPool(self):
        # type: () -> DataPool
        if self._dataPool is _omit:
            raise AttributeError('dataPool not found')
        return self._dataPool
    
    @dataPool.setter
    def dataPool(self, new_val):
        # type: (DataPool) -> None
        self._dataPool = new_val

    def to_json(self):
        res = {
            'gateway': self.gateway.to_json() if self._gateway not in [None, _omit] else self._gateway,
            'metadataPool': self.metadataPool.to_json() if self._metadataPool not in [None, _omit] else self._metadataPool,
            'dataPool': self.dataPool.to_json() if self._dataPool not in [None, _omit] else self._dataPool,
        }
        return {k: v for k, v in res.items() if v is not _omit}

    @classmethod
    def from_json(cls, data):
        # type: (dict) -> Spec
        return cls(
            gateway=Gateway.from_json(data['gateway']) if 'gateway' in data else _omit,
            metadataPool=MetadataPool.from_json(data['metadataPool']) if 'metadataPool' in data else _omit,
            dataPool=DataPool.from_json(data['dataPool']) if 'dataPool' in data else _omit,
        )


class CephObjectStore(object):
    def __init__(self,
                 apiVersion=_omit,  # type: str
                 kind="CephObjectStore",  # type: str
                 metadata=_omit,  # type: Any
                 spec=_omit,  # type: Spec
                 ):
        self.apiVersion = apiVersion
        self.kind = kind
        self.metadata = metadata
        self.spec = spec

    @property
    def apiVersion(self):
        # type: () -> str
        if self._apiVersion is _omit:
            raise AttributeError('apiVersion not found')
        return self._apiVersion
    
    @apiVersion.setter
    def apiVersion(self, new_val):
        # type: (str) -> None
        self._apiVersion = new_val
    
    @property
    def kind(self):
        # type: () -> str
        if self._kind is _omit:
            raise AttributeError('kind not found')
        return self._kind
    
    @kind.setter
    def kind(self, new_val):
        # type: (str) -> None
        self._kind = new_val
    
    @property
    def metadata(self):
        # type: () -> Any
        if self._metadata is _omit:
            raise AttributeError('metadata not found')
        return self._metadata
    
    @metadata.setter
    def metadata(self, new_val):
        # type: (Any) -> None
        self._metadata = new_val
    
    @property
    def spec(self):
        # type: () -> Spec
        if self._spec is _omit:
            raise AttributeError('spec not found')
        return self._spec
    
    @spec.setter
    def spec(self, new_val):
        # type: (Spec) -> None
        self._spec = new_val

    def to_json(self):
        res = {
            'apiVersion': self._apiVersion,
            'kind': self._kind,
            'metadata': self._metadata,
            'spec': self.spec.to_json() if self._spec not in [None, _omit] else self._spec,
        }
        return {k: v for k, v in res.items() if v is not _omit}

    @classmethod
    def from_json(cls, data):
        # type: (dict) -> CephObjectStore
        return cls(
            apiVersion=data.get('apiVersion', _omit),
            kind=data.get('kind', _omit),
            metadata=data.get('metadata', _omit),
            spec=Spec.from_json(data['spec']) if 'spec' in data else _omit,
        )
